# starship.zsh - Starship prompt configuration
# This file is sourced after oh-my-zsh and plugins load

# =============================================================================
# Starship Timing and State Management
# =============================================================================

# ZSH has a quirk where `preexec` is only run if a command is actually run (i.e
# pressing ENTER at an empty command line will not cause preexec to fire). This
# can cause timing issues, as a user who presses "ENTER" without running a command
# will see the time to the start of the last command, which may be very large.

# To fix this, we create STARSHIP_START_TIME upon preexec() firing, and destroy it
# after drawing the prompt. This ensures that the timing for one command is only
# ever drawn once (for the prompt immediately after it is run).

zmodload zsh/parameter  # Needed to access jobstates variable for STARSHIP_JOBS_COUNT

# Defines a function `__starship_get_time` that sets the time since epoch in millis in STARSHIP_CAPTURED_TIME.
if [[ $ZSH_VERSION == ([1-4]*) ]]; then
    # ZSH <= 5; Does not have a built-in variable so we will rely on Starship's inbuilt time function.
    __starship_get_time() {
        STARSHIP_CAPTURED_TIME=$(/opt/homebrew/bin/starship time)
    }
else
    zmodload zsh/datetime
    zmodload zsh/mathfunc
    __starship_get_time() {
        (( STARSHIP_CAPTURED_TIME = int(rint(EPOCHREALTIME * 1000)) ))
    }
fi

# =============================================================================
# Ghostty Color Sync Function
# =============================================================================

# Sync ghostty colors to starship configuration
# Reads colors from ghostty +show-config and generates palette
sync-ghostty-colors() {
    # Resolve symlink if needed
    local starship_config="${XDG_CONFIG_HOME:-$HOME/.config}/starship.toml"
    if [[ -L "$starship_config" ]]; then
        starship_config=$(readlink -f "$starship_config" 2>/dev/null || greadlink -f "$starship_config" 2>/dev/null || python3 -c "import os; print(os.path.realpath('$starship_config'))")
    fi

    # Check if starship config exists
    if [[ ! -f "$starship_config" ]]; then
        echo "Error: $starship_config not found"
        return 1
    fi

    echo "Syncing ghostty colors to starship..."

    # Get colors from ghostty
    local ghostty_config=$(ghostty +show-config 2>/dev/null)
    if [[ -z "$ghostty_config" ]]; then
        echo "Error: Could not get ghostty config"
        echo "Make sure ghostty is installed and in your PATH"
        return 1
    fi

    # Parse colors into associative array
    local -A colors
    while read -r line; do
        # Skip empty lines
        [[ -z "$line" ]] && continue

        if [[ "$line" =~ ^palette\ =\ ([0-9]+)=#([0-9a-fA-F]+) ]]; then
            # Extract palette number and hex value
            # Format: palette = 0=#1d1f21
            local num="${match[1]}"
            local hex="#${match[2]}"
            colors[color$num]=$hex
        elif [[ "$line" =~ ^background\ =\ (#[0-9a-fA-F]+) ]]; then
            colors[background]="${match[1]}"
        elif [[ "$line" =~ ^foreground\ =\ (#[0-9a-fA-F]+) ]]; then
            colors[foreground]="${match[1]}"
        fi
    done <<< "$ghostty_config"

    # Map color numbers to ANSI names
    local -A ansi_names=(
        [0]="black"
        [1]="red"
        [2]="green"
        [3]="yellow"
        [4]="blue"
        [5]="magenta"
        [6]="cyan"
        [7]="white"
        [8]="bright_black"
        [9]="bright_red"
        [10]="bright_green"
        [11]="bright_yellow"
        [12]="bright_blue"
        [13]="bright_magenta"
        [14]="bright_cyan"
        [15]="bright_white"
    )

    # Generate palette section
    local palette_section="
# =============================================================================
# Ghostty Palette (Generated by sync-ghostty-colors)
# =============================================================================
# Auto-generated from: ghostty +show-config
# Run sync-ghostty-colors again after changing ghostty theme

[palettes.ghostty]"

    # Add ANSI colors
    for num in {0..15}; do
        local name=${ansi_names[$num]}
        local hex=${colors[color$num]:-#000000}
        palette_section+="\n$name = \"$hex\""
    done

    # Add background/foreground
    palette_section+="\nbackground = \"${colors[background]:-#000000}\""
    palette_section+="\nforeground = \"${colors[foreground]:-#ffffff}\""

    # Remove old ghostty palette section if exists
    local marker="# Ghostty Palette (Generated by sync-ghostty-colors)"
    if grep -q "$marker" "$starship_config"; then
        # Use perl for more reliable in-place editing
        perl -i.bak -ne "print unless /# Ghostty Palette \(Generated by sync-ghostty-colors\)/ .. 0" "$starship_config"
        echo "Removed old ghostty palette section"
    fi

    # Remove the optional/placeholder section
    local opt_marker="# Ghostty Palette (Optional Advanced Usage)"
    if grep -q "$opt_marker" "$starship_config"; then
        perl -i.bak -ne "print unless /# Ghostty Palette \(Optional Advanced Usage\)/ .. 0" "$starship_config"
    fi

    # Append new palette
    echo "$palette_section" >> "$starship_config"

    # Update palette setting
    if grep -q "^palette = " "$starship_config"; then
        perl -i.bak -pe 's/^palette = .*/palette = "ghostty"/' "$starship_config"
    else
        # Add after $schema line
        perl -i.bak -pe 's/(^\"\$schema\" = .*$)/$1\npalette = "ghostty"/' "$starship_config"
    fi

    # Clean up backup
    rm -f "${starship_config}.bak"

    echo "✓ Ghostty colors synced to starship"
    echo "✓ Palette set to 'ghostty'"
    echo ""
    echo "Colors imported:"
    for num in {0..7}; do
        echo "  ${ansi_names[$num]}: ${colors[color$num]}"
    done
    echo ""
    echo "Reload your prompt: prompt-reload"
}

# =============================================================================
# Custom Prompt Functions
# =============================================================================

# Reload starship prompt after configuration changes
prompt-reload() {
    # Clear prompt cache and reinitialize
    unset PROMPT RPROMPT PROMPT2

    # Reinitialize starship
    PROMPT='$('/opt/homebrew/bin/starship' prompt --terminal-width="$COLUMNS" --keymap="${KEYMAP:-}" --status="$STARSHIP_CMD_STATUS" --pipestatus="${STARSHIP_PIPE_STATUS[*]}" --cmd-duration="${STARSHIP_DURATION:-}" --jobs="$STARSHIP_JOBS_COUNT")'
    RPROMPT='$('/opt/homebrew/bin/starship' prompt --right --terminal-width="$COLUMNS" --keymap="${KEYMAP:-}" --status="$STARSHIP_CMD_STATUS" --pipestatus="${STARSHIP_PIPE_STATUS[*]}" --cmd-duration="${STARSHIP_DURATION:-}" --jobs="$STARSHIP_JOBS_COUNT")'
    PROMPT2="$(/opt/homebrew/bin/starship prompt --continuation)"

    # Redraw prompt
    zle && zle reset-prompt

    echo "Starship prompt reloaded"
}

# Prompt mode switching functions (project-specific)
# These modify the transient prompt format by setting environment variable

# Default transient format - dir:repo [symbol] ❯
export STARSHIP_TRANSIENT_FORMAT='${custom.context_dir}${custom.git_branch_symbol}$character'

prompt-mode-minimal() {
    echo "Switching to minimal transient prompt..."
    export STARSHIP_TRANSIENT_FORMAT='$character'
    echo "Minimal mode: Shows only prompt character"
}

prompt-mode-standard() {
    echo "Switching to standard transient prompt..."
    export STARSHIP_TRANSIENT_FORMAT='${custom.context_dir}${custom.git_branch_symbol}$character'
    echo "Standard mode: Shows dir:repo + branch symbol + character"
}

prompt-mode-kube() {
    echo "Switching to kubernetes-focused transient prompt..."
    export STARSHIP_TRANSIENT_FORMAT='$kubernetes${custom.context_dir}${custom.git_branch_symbol}$character'
    echo "Kubernetes mode: Shows k8s + dir + branch symbol + character"
}

prompt-mode-container() {
    echo "Switching to container-focused transient prompt..."
    export STARSHIP_TRANSIENT_FORMAT='$docker_context${custom.context_dir}${custom.git_branch_symbol}$character'
    echo "Container mode: Shows container + dir + branch symbol + character"
}

prompt-mode-full() {
    echo "Switching to full transient prompt..."
    export STARSHIP_TRANSIENT_FORMAT='${custom.context_dir}${custom.git_branch_symbol}$git_status$character'
    echo "Full mode: Shows dir + branch symbol + git status + character"
}

# Display current prompt configuration
prompt-status() {
    echo "Current Starship Configuration:"
    echo "  Using ANSI colors (respects ghostty theme)"
    echo "  Transient format: ${STARSHIP_TRANSIENT_FORMAT:-<default>}"
    echo ""
    echo "Available commands:"
    echo "  sync-ghostty-colors  - Sync exact hex values from ghostty"
    echo "  Mode:  prompt-mode-{minimal,standard,kube,container,full}"
    echo "  Other: prompt-reload, prompt-status"
    echo ""
    echo "By default, starship uses ANSI color names that automatically"
    echo "map to your ghostty theme. Run sync-ghostty-colors for exact"
    echo "hex value control."
}

# =============================================================================
# Starship Hook Functions
# =============================================================================

# The two functions below follow the naming convention `prompt_<theme>_<hook>`
# for compatibility with Zsh's prompt system. See
# https://github.com/zsh-users/zsh/blob/2876c25a28b8052d6683027998cc118fc9b50157/Functions/Prompts/promptinit#L155

# Runs before each new command line.
prompt_starship_precmd() {
    # Save the status, because subsequent commands in this function will change $?
    STARSHIP_CMD_STATUS=$? STARSHIP_PIPE_STATUS=(${pipestatus[@]})

    # Calculate duration if a command was executed
    if (( ${+STARSHIP_START_TIME} )); then
        __starship_get_time && (( STARSHIP_DURATION = STARSHIP_CAPTURED_TIME - STARSHIP_START_TIME ))
        unset STARSHIP_START_TIME
    # Drop status and duration otherwise
    else
        unset STARSHIP_DURATION STARSHIP_CMD_STATUS STARSHIP_PIPE_STATUS
    fi

    # Use length of jobstates array as number of jobs. Expansion fails inside
    # quotes so we set it here and then use the value later on.
    STARSHIP_JOBS_COUNT=${#jobstates}
}

# Runs after the user submits the command line, but before it is executed and
# only if there's an actual command to run
prompt_starship_preexec() {
    __starship_get_time && STARSHIP_START_TIME=$STARSHIP_CAPTURED_TIME
}

# Add hook functions
autoload -Uz add-zsh-hook
add-zsh-hook precmd prompt_starship_precmd
add-zsh-hook preexec prompt_starship_preexec

# Set up a function to redraw the prompt if the user switches vi modes
starship_zle-keymap-select() {
    zle reset-prompt
}

## Check for existing keymap-select widget.
# zle-keymap-select is a special widget so it'll be "user:fnName" or nothing. Let's get fnName only.
__starship_preserved_zle_keymap_select=${widgets[zle-keymap-select]#user:}
if [[ -z $__starship_preserved_zle_keymap_select ]]; then
    zle -N zle-keymap-select starship_zle-keymap-select;
else
    # Define a wrapper fn to call the original widget fn and then Starship's.
    starship_zle-keymap-select-wrapped() {
        $__starship_preserved_zle_keymap_select "$@";
        starship_zle-keymap-select "$@";
    }
    zle -N zle-keymap-select starship_zle-keymap-select-wrapped;
fi

# =============================================================================
# Starship Environment and Initialization
# =============================================================================

export STARSHIP_SHELL="zsh"

# Set up the session key that will be used to store logs
STARSHIP_SESSION_KEY="$RANDOM$RANDOM$RANDOM$RANDOM$RANDOM"; # Random generates a number b/w 0 - 32767
STARSHIP_SESSION_KEY="${STARSHIP_SESSION_KEY}0000000000000000" # Pad it to 16+ chars.
export STARSHIP_SESSION_KEY=${STARSHIP_SESSION_KEY:0:16}; # Trim to 16-digits if excess.

VIRTUAL_ENV_DISABLE_PROMPT=1

setopt promptsubst

# Enable transient prompt
# This makes old prompts collapse to a minimal version
enable_transience() {
    # Variable to track if we should use transient prompt
    export STARSHIP_USE_TRANSIENT=${STARSHIP_USE_TRANSIENT:-1}

    # Override prompt_starship_precmd to implement transience
    __starship_transient_precmd() {
        # First, run the standard starship precmd
        prompt_starship_precmd

        # If this is not the first prompt, replace the previous full prompt with transient
        if [[ $STARSHIP_USE_TRANSIENT == 1 ]]; then
            # Use the transient format for completed commands
            # This is shown for old prompts, while new prompts show the full format
            # The transient format is stored in STARSHIP_TRANSIENT_FORMAT variable
            :  # Placeholder - transient rendering happens via prompt formatting
        fi
    }

    # Replace the precmd hook
    add-zsh-hook -d precmd prompt_starship_precmd
    add-zsh-hook precmd __starship_transient_precmd
}

# Initialize prompts
PROMPT='$('/opt/homebrew/bin/starship' prompt --terminal-width="$COLUMNS" --keymap="${KEYMAP:-}" --status="$STARSHIP_CMD_STATUS" --pipestatus="${STARSHIP_PIPE_STATUS[*]}" --cmd-duration="${STARSHIP_DURATION:-}" --jobs="$STARSHIP_JOBS_COUNT")'
RPROMPT='$('/opt/homebrew/bin/starship' prompt --right --terminal-width="$COLUMNS" --keymap="${KEYMAP:-}" --status="$STARSHIP_CMD_STATUS" --pipestatus="${STARSHIP_PIPE_STATUS[*]}" --cmd-duration="${STARSHIP_DURATION:-}" --jobs="$STARSHIP_JOBS_COUNT")'
PROMPT2="$(/opt/homebrew/bin/starship prompt --continuation)"

# Enable transient prompts
enable_transience
